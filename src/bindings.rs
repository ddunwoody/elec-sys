/* automatically generated by rust-bindgen 0.65.1 */

pub type va_list = __builtin_va_list;
pub type bool_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conf {
    _unused: [u8; 0],
}
pub type conf_t = conf;
#[doc = " A generic 3-space vector. Looking down onto a plane embedded in euclidian\n 3-space, the axes are:\n x: left-to-right (increasing right)\n y: down-to-up (increasing up)\n z: away-towards viewer (increasing towards viewer)\n```\n\t\t\tY (incr up)\n\t\t\t^\n\t\t\t|\n\t\t\t|\n\t\t\t|\n\t\t\tx-------->\n\t\t\tZ        X (incr right)\n\t(incr towards us)\n```"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vect3_t {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[test]
fn bindgen_test_layout_vect3_t() {
    const UNINIT: ::std::mem::MaybeUninit<vect3_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vect3_t>(),
        24usize,
        concat!("Size of: ", stringify!(vect3_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vect3_t>(),
        8usize,
        concat!("Alignment of ", stringify!(vect3_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vect3_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vect3_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vect3_t),
            "::",
            stringify!(z)
        )
    );
}
#[doc = " Generic 2-space vector. On euclidian 2-space, axes are:\n x: left-to-right (increasing right)\n y: down-to-up (increasing up)\n```\n Y (incr up)\n ^\n |\n |\n |\n +------->\n         X (incr right)\n```"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vect2_s {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_vect2_s() {
    const UNINIT: ::std::mem::MaybeUninit<vect2_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vect2_s>(),
        16usize,
        concat!("Size of: ", stringify!(vect2_s))
    );
    assert_eq!(
        ::std::mem::align_of::<vect2_s>(),
        8usize,
        concat!("Alignment of ", stringify!(vect2_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vect2_s),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vect2_s),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " Generic 2-space vector. On euclidian 2-space, axes are:\n x: left-to-right (increasing right)\n y: down-to-up (increasing up)\n```\n Y (incr up)\n ^\n |\n |\n |\n +------->\n         X (incr right)\n```"]
pub type vect2_t = vect2_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elec_sys_s {
    _unused: [u8; 0],
}
pub type elec_sys_t = elec_sys_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elec_comp_s {
    _unused: [u8; 0],
}
pub type elec_comp_t = elec_comp_s;
#[doc = " \\struct elec_comp_info_t\n After parsing the electrical definition, each component gets an info\n structure generated, containing the parsed information. You can\n request this structure from the component using libelec_comp2info().\n This is mostly useful for interrogating various information about the\n component, such as its type, name and various configuration details\n pertaining to its configuration.\n\n Each elec_comp_info_t structure contains a union of various\n component-type-specific information. You should only access the\n type-specific structures matched to the component type."]
pub type elec_comp_info_t = elec_comp_info_s;
#[doc = " A battery is a component which can hold a certain amount of\n energy. This energy can then either be discharged (when a load\n is connected to the battery), or recharged (when a generator\n or energy source of a higher voltage than the battery's output\n voltage is attached). The rate of recharge is controlled by\n the battery's internal resistance, while the rate of discharge\n is largely driven by the demands of the downstream loads. To\n simulate the effects of internal battery resistance to\n discharge, a battery will depress its output voltage as it\n approaches its power flow limits."]
pub const elec_comp_type_t_ELEC_BATT: elec_comp_type_t = 0;
#[doc = " A generator is a component which converts mechanical input\n energy into electrical output energy. You MUST supply a\n callback using libelec_gen_set_rpm_cb(), which informs\n libelec how fast the input shaft of the generator is turning.\n @see libelec_gen_set_rpm_cb()\n @see elec_get_rpm_cb_t"]
pub const elec_comp_type_t_ELEC_GEN: elec_comp_type_t = 1;
#[doc = " A Transformer-Rectifier Unit is a component which performs two\n tasks:\n\n 1. It transforms the voltage of the input to a different voltage\n\ton the output.\n 2. It rectifies AC to DC\n\n libelec's TRUs are simple devices, whose output voltage always\n scales in proportion to their input voltage. Thus, they do not\n provide a stabilized output voltage, but instead depend on the\n ability of the AC-side generator to supply a stable voltage. A\n TRU doesn't permit reverse current flow from its output side to\n the input."]
pub const elec_comp_type_t_ELEC_TRU: elec_comp_type_t = 2;
#[doc = " An inverter is conceptually the opposite of a TRU. It changes\n DC power into AC power, and optionally also changes the input\n voltage to a different output voltage.\n @see \\ref ELEC_TRU"]
pub const elec_comp_type_t_ELEC_INV: elec_comp_type_t = 3;
#[doc = " A load is a consumer of electrical energy. This can be anything\n you need it to be. libelec tells you if the load is powered\n (and how much energy it is consuming), and you then implement\n your custom systems behaviors based on that energy usage. Loads\n can either have internal power supplies, or be simple\n unregulated energy consumers. You can customize all of this\n behavior to suit your needs."]
pub const elec_comp_type_t_ELEC_LOAD: elec_comp_type_t = 4;
#[doc = " Buses are the interconnecting \"tissue\" of the libelec network.\n Every component on the network must connect to one or more\n buses, and the buses themselves serve to distribute energy\n flows throughout the network. libelec buses are idealized\n power distribution mechanisms with no internal resistance."]
pub const elec_comp_type_t_ELEC_BUS: elec_comp_type_t = 5;
#[doc = " Circuit breakers are devices which allow the passage of\n electrical current when closed. If open, current is not\n allowed to flow. A breaker can become open by either by\n manual pilot action, or automatically if the current flowing\n through the breaker exceeds the breaker's maximum rating. As\n such, circuit breakers are safety devices which prevent\n excessive current draw to protect the electrical network from\n damage due to faults or short-circuits.\n\n libelec assumes CBs as being specifically thermal circuit\n breakers, which are breakers where a small amount of energy\n is used to heat up an internal filament. This amount of\n energy loss is carefully callibrated such that when current\n flow through the breaker exceeds its rating, the filament\n deforms sufficiently to trigger an internal control circuit,\n which then opens the breaker. As such, thermal breakers have\n a certain amount of \"inertia\" before responding. If the\n current exceedance is very brief and/or not very high, the\n filament's thermal inertia might cause the breaker not to\n \"trip.\" Conversely, when the breaker trips, the filament\n might remain very hot and must cool off - the operator must\n wait a few seconds before attempting to close the breaker\n again, to account for this cooling period."]
pub const elec_comp_type_t_ELEC_CB: elec_comp_type_t = 6;
#[doc = " Shunts are current measuring devices inserted in-line with\n a circuit. In reality, shunts are very small, carefully\n callibrated resistors, which cause a small amount of voltage\n drop across their leads. This amount of voltage drop is then\n measured using a voltmeter and converted into a current\n measurement mathematically.\n\n Since a properly sized shunt is meant to only cause a very\n small voltage drop in the circuit, libelec shunts are\n idealized devices which cause no voltage drop at all. You\n can also use these idealized shunts to represent other\n current measuring devices, such as AC current clamps (which\n cause no voltage drop in the circuit)."]
pub const elec_comp_type_t_ELEC_SHUNT: elec_comp_type_t = 7;
#[doc = " Ties are devices which connect two or more buses together.\n You can think of ties as a generalization of contactors and\n relays. Each of the endpoints of a tie has two possible\n states: tied or not tied. When tied, the endpoint allows\n current to pass (in any direction) to all other endpoints\n which are currently tied. Conceptually, the tie behaves as\n a single electrical node, with links to the outside world\n which can be dynamically connected and disconnected:\n```\n    4-pole tie fully open                B & C tied, A & D open\n    (no current can flow)           (current can flow between B & C)\n\n          A o   o C                           A o   o B\n                                                   /\n              +                                   +\n                                                 /\n          B o   o D                           C o   o D\n\n\n      A & B tied, C & D open              All endpoints tied\n (current can flow between A & B)   (current can flow between all)\n\n          A o   o B                           A o   o B\n             \\ /                                 \\ /\n              +                                   +\n                                                 / \\\n          C o   o D                           C o   o D\n```"]
pub const elec_comp_type_t_ELEC_TIE: elec_comp_type_t = 8;
#[doc = " A diode is a component which prevents current flow opposite to\n the diode's forward sense. libelec's diode are DC-only devices\n and cannot be used on AC circuits. Use a component of type\n ELEC_TRU to implement an AC-to-DC rectifier."]
pub const elec_comp_type_t_ELEC_DIODE: elec_comp_type_t = 9;
#[doc = " This is a pseudo component, only used placing text labels on\n the graphical network drawing. It plays no role in the actual\n electrical simulation."]
pub const elec_comp_type_t_ELEC_LABEL_BOX: elec_comp_type_t = 10;
#[doc = " Identifies the type of electrical component. Every component in a libelec\n network must be one of these enumerations."]
pub type elec_comp_type_t = ::std::os::raw::c_uint;
#[doc = " This is the callback type used by batteries to determine the temperature\n of the battery. Temperature has a significant effect on a battery's\n ability to provide current, as well as its absolute energy capacity.\n @return The temperature the battery in **Kelvin**."]
pub type elec_get_temp_cb_t = ::std::option::Option<
    unsafe extern "C" fn(comp: *mut elec_comp_t, userinfo: *mut ::std::os::raw::c_void) -> f64,
>;
#[doc = " Info structure describing a battery."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elec_batt_info_t {
    #[doc = "< Nominal voltage."]
    pub volts: f64,
    #[doc = "< Capacity in Joules at 15°C."]
    pub capacity: f64,
    #[doc = "< Max power draw in Watts."]
    pub max_pwr: f64,
    #[doc = "< Charging resistance, Ohms."]
    pub chg_R: f64,
    #[doc = " Battery temperature callback as set using libelec_batt_set_temp_cb().\n @see elec_get_temp_cb_t"]
    pub get_temp: elec_get_temp_cb_t,
}
#[test]
fn bindgen_test_layout_elec_batt_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<elec_batt_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<elec_batt_info_t>(),
        40usize,
        concat!("Size of: ", stringify!(elec_batt_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<elec_batt_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(elec_batt_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).volts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_batt_info_t),
            "::",
            stringify!(volts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_batt_info_t),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_pwr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_batt_info_t),
            "::",
            stringify!(max_pwr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chg_R) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_batt_info_t),
            "::",
            stringify!(chg_R)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_temp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_batt_info_t),
            "::",
            stringify!(get_temp)
        )
    );
}
#[doc = " This is the callback type used by generators to determine the speed\n of the generator's input shaft, which is then used for determining\n the generator's output voltage and frequency behavior. This callback\n is installed for generators using libelec_gen_set_rpm_cb().\n @note A generator MUST have an rpm callback configured before the\n\tnetwork can be started using libelec_sys_start().\n @param comp The component for which the generator rpm is being queried.\n @param userinfo Custom userinfo pointer, which was previously set up\n\ton the component using libelec_comp_set_userinfo().\n @return The generator rpm, using the same units as what you have used\n\tfor the `EXC_RPM`, `MIN_RPM` and `MAX_RPM` stanzas when defining\n\tthe generator in the config file. libelec doesn't enforce any\n\tspecific type of units for generator, so you can use whatever\n\tunits are most convenient."]
pub type elec_get_rpm_cb_t = ::std::option::Option<
    unsafe extern "C" fn(comp: *mut elec_comp_t, userinfo: *mut ::std::os::raw::c_void) -> f64,
>;
#[doc = " Info structure describing a generator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elec_gen_info_s {
    #[doc = "< Nominal voltage at operating rpm."]
    pub volts: f64,
    #[doc = "< Nominal frequency at operating rpm."]
    pub freq: f64,
    #[doc = "< Voltage stabilization adaptation rate."]
    pub stab_rate_U: f64,
    #[doc = "< Frequency stabilization adaptation rate."]
    pub stab_rate_f: f64,
    #[doc = "< Min rpm for generator field excitation."]
    pub exc_rpm: f64,
    #[doc = "< Min rpm at which stabilization works."]
    pub min_rpm: f64,
    #[doc = "< Max rpm at which stabilization works."]
    pub max_rpm: f64,
    #[doc = "< Watts -> efficiency curve."]
    pub eff_curve: *mut vect2_t,
    #[doc = " Generator speed callback as set using libelec_gen_set_rpm_cb().\n @see elec_get_rpm_cb_t"]
    pub get_rpm: elec_get_rpm_cb_t,
}
#[test]
fn bindgen_test_layout_elec_gen_info_s() {
    const UNINIT: ::std::mem::MaybeUninit<elec_gen_info_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<elec_gen_info_s>(),
        72usize,
        concat!("Size of: ", stringify!(elec_gen_info_s))
    );
    assert_eq!(
        ::std::mem::align_of::<elec_gen_info_s>(),
        8usize,
        concat!("Alignment of ", stringify!(elec_gen_info_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).volts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_gen_info_s),
            "::",
            stringify!(volts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freq) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_gen_info_s),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stab_rate_U) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_gen_info_s),
            "::",
            stringify!(stab_rate_U)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stab_rate_f) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_gen_info_s),
            "::",
            stringify!(stab_rate_f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exc_rpm) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_gen_info_s),
            "::",
            stringify!(exc_rpm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_rpm) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_gen_info_s),
            "::",
            stringify!(min_rpm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_rpm) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_gen_info_s),
            "::",
            stringify!(max_rpm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eff_curve) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_gen_info_s),
            "::",
            stringify!(eff_curve)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_rpm) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_gen_info_s),
            "::",
            stringify!(get_rpm)
        )
    );
}
#[doc = " Info structure describing a generator."]
pub type elec_gen_info_t = elec_gen_info_s;
#[doc = " Info structure describing a TRU, inverter or battery charger."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elec_tru_info_t {
    #[doc = "< Nominal input voltage."]
    pub in_volts: f64,
    #[doc = "< Minimum input voltage."]
    pub min_volts: f64,
    #[doc = "< Nominal output voltage."]
    pub out_volts: f64,
    #[doc = "< Output frequency (for inverters)"]
    pub out_freq: f64,
    #[doc = "< Output Watts -> efficiency curve"]
    pub eff_curve: *mut vect2_t,
    #[doc = "< AC bus side"]
    pub ac: *const elec_comp_info_t,
    #[doc = "< DC bus side"]
    pub dc: *const elec_comp_info_t,
    #[doc = " When operating in battery-charger mode, `charger' must be true\n and the battery link non-NULL."]
    pub charger: bool,
    pub batt: *const elec_comp_info_t,
    pub batt_conn: *const elec_comp_info_t,
    #[doc = "< Charger current limit (in Amps)."]
    pub curr_lim: f64,
}
#[test]
fn bindgen_test_layout_elec_tru_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<elec_tru_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<elec_tru_info_t>(),
        88usize,
        concat!("Size of: ", stringify!(elec_tru_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<elec_tru_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(elec_tru_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).in_volts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_tru_info_t),
            "::",
            stringify!(in_volts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_volts) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_tru_info_t),
            "::",
            stringify!(min_volts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out_volts) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_tru_info_t),
            "::",
            stringify!(out_volts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out_freq) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_tru_info_t),
            "::",
            stringify!(out_freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eff_curve) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_tru_info_t),
            "::",
            stringify!(eff_curve)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ac) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_tru_info_t),
            "::",
            stringify!(ac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dc) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_tru_info_t),
            "::",
            stringify!(dc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).charger) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_tru_info_t),
            "::",
            stringify!(charger)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).batt) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_tru_info_t),
            "::",
            stringify!(batt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).batt_conn) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_tru_info_t),
            "::",
            stringify!(batt_conn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curr_lim) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_tru_info_t),
            "::",
            stringify!(curr_lim)
        )
    );
}
#[doc = " This is the callback type used by electrical loads for cases where\n the caller has installed a custom load demand callback using\n libelec_load_set_load_cb().\n @param comp The component for which the load demand is being queried.\n @param userinfo Custom userinfo pointer, which was previously set up\n\ton the component using libelec_comp_set_userinfo().\n @return\n\t1. For components with stabilized power supplies (`STAB TRUE` in\n\t   the definition file), this callback must return the **power**\n\t   demand of the load in **Watts**.\n\t2. For components with unstabilized power supplies (`STAB FALSE`\n\t   in the definition file, the default), this callback must\n\t   return the **current** demand of the load in **Amps**."]
pub type elec_get_load_cb_t = ::std::option::Option<
    unsafe extern "C" fn(comp: *mut elec_comp_t, userinfo: *mut ::std::os::raw::c_void) -> f64,
>;
#[doc = " Info structure describing a load."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elec_load_info_t {
    #[doc = " Needs AC or DC input?"]
    pub ac: bool,
    #[doc = " Does the load have a stabilized PSU, or is constant-current?"]
    pub stab: bool,
    #[doc = " Input capacitance in Farad."]
    pub incap_C: f64,
    #[doc = " Resitance (in Ohms) for incap charging."]
    pub incap_R: f64,
    #[doc = " Incap leakage rate in Coulomb/s."]
    pub incap_leak_Qps: f64,
    #[doc = " Minimum voltage to be powered up (for libelec_comp_is_powered())"]
    pub min_volts: f64,
    #[doc = " @see elec_get_load_cb_t"]
    pub get_load: elec_get_load_cb_t,
    #[doc = " Fixed load (in Watts for stabilized and Amps for unstabilized)\n for constant-demand loads (specified using the `STD_LOAD` stanza)."]
    pub std_load: f64,
}
#[test]
fn bindgen_test_layout_elec_load_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<elec_load_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<elec_load_info_t>(),
        56usize,
        concat!("Size of: ", stringify!(elec_load_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<elec_load_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(elec_load_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_load_info_t),
            "::",
            stringify!(ac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stab) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_load_info_t),
            "::",
            stringify!(stab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).incap_C) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_load_info_t),
            "::",
            stringify!(incap_C)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).incap_R) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_load_info_t),
            "::",
            stringify!(incap_R)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).incap_leak_Qps) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_load_info_t),
            "::",
            stringify!(incap_leak_Qps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_volts) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_load_info_t),
            "::",
            stringify!(min_volts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_load) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_load_info_t),
            "::",
            stringify!(get_load)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).std_load) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_load_info_t),
            "::",
            stringify!(std_load)
        )
    );
}
#[doc = " Info structure describing a bus."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elec_bus_info_t {
    #[doc = "< Is the bus AC or DC?"]
    pub ac: bool,
    #[doc = "< Connected components"]
    pub comps: *mut *const elec_comp_info_t,
    #[doc = "< Number of components"]
    pub n_comps: usize,
}
#[test]
fn bindgen_test_layout_elec_bus_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<elec_bus_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<elec_bus_info_t>(),
        24usize,
        concat!("Size of: ", stringify!(elec_bus_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<elec_bus_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(elec_bus_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_bus_info_t),
            "::",
            stringify!(ac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).comps) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_bus_info_t),
            "::",
            stringify!(comps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_comps) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_bus_info_t),
            "::",
            stringify!(n_comps)
        )
    );
}
#[doc = " Info structure describing a circuit breaker."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elec_cb_info_t {
    #[doc = "< Max current rating"]
    pub max_amps: f64,
    #[doc = "< Heating rate"]
    pub rate: f64,
    #[doc = "< Is this breaker a fuse?"]
    pub fuse: bool,
    #[doc = "< Is a 3-phase breaker?"]
    pub triphase: bool,
}
#[test]
fn bindgen_test_layout_elec_cb_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<elec_cb_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<elec_cb_info_t>(),
        24usize,
        concat!("Size of: ", stringify!(elec_cb_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<elec_cb_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(elec_cb_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_amps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_cb_info_t),
            "::",
            stringify!(max_amps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_cb_info_t),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fuse) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_cb_info_t),
            "::",
            stringify!(fuse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).triphase) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_cb_info_t),
            "::",
            stringify!(triphase)
        )
    );
}
#[doc = " Info structure describing a diode."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elec_diode_info_t {
    #[doc = " The two sides of a diode. Slot [0] is the input, and slot [1]\n the output, so current flow can only occur [0]->[1]."]
    pub sides: [*const elec_comp_info_t; 2usize],
}
#[test]
fn bindgen_test_layout_elec_diode_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<elec_diode_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<elec_diode_info_t>(),
        16usize,
        concat!("Size of: ", stringify!(elec_diode_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<elec_diode_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(elec_diode_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sides) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_diode_info_t),
            "::",
            stringify!(sides)
        )
    );
}
pub const gui_load_type_t_GUI_LOAD_GENERIC: gui_load_type_t = 0;
pub const gui_load_type_t_GUI_LOAD_MOTOR: gui_load_type_t = 1;
pub type gui_load_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elec_label_box_info_t {
    pub pos: vect2_t,
    pub sz: vect2_t,
    pub font_scale: f64,
}
#[test]
fn bindgen_test_layout_elec_label_box_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<elec_label_box_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<elec_label_box_info_t>(),
        40usize,
        concat!("Size of: ", stringify!(elec_label_box_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<elec_label_box_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(elec_label_box_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_label_box_info_t),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sz) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_label_box_info_t),
            "::",
            stringify!(sz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).font_scale) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_label_box_info_t),
            "::",
            stringify!(font_scale)
        )
    );
}
#[doc = " \\struct elec_comp_info_t\n After parsing the electrical definition, each component gets an info\n structure generated, containing the parsed information. You can\n request this structure from the component using libelec_comp2info().\n This is mostly useful for interrogating various information about the\n component, such as its type, name and various configuration details\n pertaining to its configuration.\n\n Each elec_comp_info_t structure contains a union of various\n component-type-specific information. You should only access the\n type-specific structures matched to the component type."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct elec_comp_info_s {
    #[doc = "< Component type."]
    pub type_: elec_comp_type_t,
    #[doc = "< Component name."]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " Userinfo pointer set using libelec_comp_set_userinfo()."]
    pub userinfo: *mut ::std::os::raw::c_void,
    #[doc = " Was this component auto-generated? CBs are auto-generated\n when specified using the LOADCB stanza."]
    pub autogen: bool,
    #[doc = " Descriptive location name (e.g. breaker panel row & column)."]
    pub location: [::std::os::raw::c_char; 32usize],
    #[doc = " Internal resistance in Ohms."]
    pub int_R: f64,
    #[doc = " Line number in input file on which the component was found."]
    pub parse_linenum: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: elec_comp_info_s__bindgen_ty_1,
    pub gui: elec_comp_info_s__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union elec_comp_info_s__bindgen_ty_1 {
    #[doc = "< Valid for an ELEC_BATT."]
    pub batt: elec_batt_info_t,
    #[doc = "< Valid for an ELEC_GEN."]
    pub gen: elec_gen_info_t,
    #[doc = " Valid for an ELEC_TRU and ELEC_INV."]
    pub tru: elec_tru_info_t,
    #[doc = "< Valid for an ELEC_LOAD."]
    pub load: elec_load_info_t,
    #[doc = "< Valid for an ELEC_BUS."]
    pub bus: elec_bus_info_t,
    #[doc = "< Valid for an ELEC_CB."]
    pub cb: elec_cb_info_t,
    #[doc = "< Valid for an ELEC_DIODE."]
    pub diode: elec_diode_info_t,
    #[doc = " Valid for an ELEC_LABEL_BOX"]
    pub label_box: elec_label_box_info_t,
}
#[test]
fn bindgen_test_layout_elec_comp_info_s__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<elec_comp_info_s__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<elec_comp_info_s__bindgen_ty_1>(),
        88usize,
        concat!("Size of: ", stringify!(elec_comp_info_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<elec_comp_info_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(elec_comp_info_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).batt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_comp_info_s__bindgen_ty_1),
            "::",
            stringify!(batt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_comp_info_s__bindgen_ty_1),
            "::",
            stringify!(gen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tru) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_comp_info_s__bindgen_ty_1),
            "::",
            stringify!(tru)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_comp_info_s__bindgen_ty_1),
            "::",
            stringify!(load)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_comp_info_s__bindgen_ty_1),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_comp_info_s__bindgen_ty_1),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).diode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_comp_info_s__bindgen_ty_1),
            "::",
            stringify!(diode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).label_box) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_comp_info_s__bindgen_ty_1),
            "::",
            stringify!(label_box)
        )
    );
}
#[doc = " Visual information, for drawing on the network diagram plot"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elec_comp_info_s__bindgen_ty_2 {
    pub pos: vect2_t,
    pub sz: f64,
    pub rot: ::std::os::raw::c_int,
    pub load_type: gui_load_type_t,
    pub virt: bool,
    pub invis: bool,
    pub color: vect3_t,
}
#[test]
fn bindgen_test_layout_elec_comp_info_s__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<elec_comp_info_s__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<elec_comp_info_s__bindgen_ty_2>(),
        64usize,
        concat!("Size of: ", stringify!(elec_comp_info_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<elec_comp_info_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(elec_comp_info_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_comp_info_s__bindgen_ty_2),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sz) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_comp_info_s__bindgen_ty_2),
            "::",
            stringify!(sz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rot) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_comp_info_s__bindgen_ty_2),
            "::",
            stringify!(rot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load_type) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_comp_info_s__bindgen_ty_2),
            "::",
            stringify!(load_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).virt) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_comp_info_s__bindgen_ty_2),
            "::",
            stringify!(virt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).invis) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_comp_info_s__bindgen_ty_2),
            "::",
            stringify!(invis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_comp_info_s__bindgen_ty_2),
            "::",
            stringify!(color)
        )
    );
}
#[test]
fn bindgen_test_layout_elec_comp_info_s() {
    const UNINIT: ::std::mem::MaybeUninit<elec_comp_info_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<elec_comp_info_s>(),
        232usize,
        concat!("Size of: ", stringify!(elec_comp_info_s))
    );
    assert_eq!(
        ::std::mem::align_of::<elec_comp_info_s>(),
        8usize,
        concat!("Alignment of ", stringify!(elec_comp_info_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_comp_info_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_comp_info_s),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userinfo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_comp_info_s),
            "::",
            stringify!(userinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).autogen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_comp_info_s),
            "::",
            stringify!(autogen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_comp_info_s),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_R) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_comp_info_s),
            "::",
            stringify!(int_R)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parse_linenum) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_comp_info_s),
            "::",
            stringify!(parse_linenum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gui) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(elec_comp_info_s),
            "::",
            stringify!(gui)
        )
    );
}
#[doc = " Custom physics callback, which you can install using libelec_add_user_cb(),\n or remove using libelec_remove_user_cb(). This will be called from the\n physics calculation thread, allowing you perform precise accounting of\n all physics state as it's being calculated.\n @see libelec_add_user_cb()\n @see libelec_remove_user_cb()"]
pub type elec_user_cb_t = ::std::option::Option<
    unsafe extern "C" fn(sys: *mut elec_sys_t, pre: bool, userinfo: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn libelec_new(filename: *const ::std::os::raw::c_char) -> *mut elec_sys_t;
}
extern "C" {
    pub fn libelec_destroy(sys: *mut elec_sys_t);
}
extern "C" {
    pub fn libelec_get_comp_infos(
        sys: *const elec_sys_t,
        num_infos: *mut usize,
    ) -> *mut elec_comp_info_t;
}
extern "C" {
    pub fn libelec_sys_start(sys: *mut elec_sys_t) -> bool;
}
extern "C" {
    pub fn libelec_sys_stop(sys: *mut elec_sys_t);
}
extern "C" {
    pub fn libelec_sys_is_started(sys: *const elec_sys_t) -> bool;
}
extern "C" {
    pub fn libelec_sys_can_start(sys: *const elec_sys_t) -> bool;
}
extern "C" {
    pub fn libelec_sys_set_time_factor(sys: *mut elec_sys_t, time_factor: f64);
}
extern "C" {
    pub fn libelec_sys_get_time_factor(sys: *const elec_sys_t) -> f64;
}
extern "C" {
    pub fn libelec_serialize(
        sys: *mut elec_sys_t,
        ser: *mut conf_t,
        prefix: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn libelec_deserialize(
        sys: *mut elec_sys_t,
        ser: *const conf_t,
        prefix: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn libelec_add_user_cb(
        sys: *mut elec_sys_t,
        pre: bool,
        cb: elec_user_cb_t,
        userinfo: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn libelec_remove_user_cb(
        sys: *mut elec_sys_t,
        pre: bool,
        cb: elec_user_cb_t,
        userinfo: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn libelec_comp_find(
        sys: *mut elec_sys_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut elec_comp_t;
}
extern "C" {
    pub fn libelec_walk_comps(
        sys: *mut elec_sys_t,
        cb: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut elec_comp_t, arg2: *mut ::std::os::raw::c_void),
        >,
        userinfo: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn libelec_comp2info(comp: *const elec_comp_t) -> *const elec_comp_info_t;
}
extern "C" {
    pub fn libelec_comp_is_AC(comp: *const elec_comp_t) -> bool;
}
extern "C" {
    pub fn libelec_comp_get_num_conns(comp: *const elec_comp_t) -> usize;
}
extern "C" {
    pub fn libelec_comp_get_conn(comp: *const elec_comp_t, i: usize) -> *mut elec_comp_t;
}
extern "C" {
    pub fn libelec_comp_get_in_volts(comp: *const elec_comp_t) -> f64;
}
extern "C" {
    pub fn libelec_comp_get_out_volts(comp: *const elec_comp_t) -> f64;
}
extern "C" {
    pub fn libelec_comp_get_in_amps(comp: *const elec_comp_t) -> f64;
}
extern "C" {
    pub fn libelec_comp_get_out_amps(comp: *const elec_comp_t) -> f64;
}
extern "C" {
    pub fn libelec_comp_get_in_pwr(comp: *const elec_comp_t) -> f64;
}
extern "C" {
    pub fn libelec_comp_get_out_pwr(comp: *const elec_comp_t) -> f64;
}
extern "C" {
    pub fn libelec_comp_get_in_freq(comp: *const elec_comp_t) -> f64;
}
extern "C" {
    pub fn libelec_comp_get_out_freq(comp: *const elec_comp_t) -> f64;
}
extern "C" {
    pub fn libelec_comp_get_incap_volts(comp: *const elec_comp_t) -> f64;
}
extern "C" {
    pub fn libelec_comp_is_powered(comp: *const elec_comp_t) -> bool;
}
extern "C" {
    pub fn libelec_comp_set_failed(comp: *mut elec_comp_t, failed: bool);
}
extern "C" {
    pub fn libelec_comp_get_failed(comp: *const elec_comp_t) -> bool;
}
extern "C" {
    pub fn libelec_comp_set_shorted(comp: *mut elec_comp_t, shorted: bool);
}
extern "C" {
    pub fn libelec_comp_get_shorted(comp: *const elec_comp_t) -> bool;
}
extern "C" {
    pub fn libelec_gen_set_random_volts(comp: *mut elec_comp_t, stddev: f64) -> f64;
}
extern "C" {
    pub fn libelec_gen_set_random_freq(comp: *mut elec_comp_t, stddev: f64) -> f64;
}
extern "C" {
    pub fn libelec_comp_set_userinfo(comp: *mut elec_comp_t, userinfo: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn libelec_comp_get_userinfo(comp: *const elec_comp_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn libelec_batt_set_temp_cb(batt: *mut elec_comp_t, cb: elec_get_temp_cb_t);
}
extern "C" {
    pub fn libelec_batt_get_temp_cb(batt: *const elec_comp_t) -> elec_get_temp_cb_t;
}
extern "C" {
    pub fn libelec_gen_set_rpm_cb(gen: *mut elec_comp_t, cb: elec_get_rpm_cb_t);
}
extern "C" {
    pub fn libelec_gen_get_rpm_cb(gen: *const elec_comp_t) -> elec_get_rpm_cb_t;
}
extern "C" {
    pub fn libelec_load_set_load_cb(load: *mut elec_comp_t, cb: elec_get_load_cb_t);
}
extern "C" {
    pub fn libelec_load_get_load_cb(load: *mut elec_comp_t) -> elec_get_load_cb_t;
}
extern "C" {
    pub fn libelec_cb_set(comp: *mut elec_comp_t, set: bool);
}
extern "C" {
    pub fn libelec_cb_get(comp: *const elec_comp_t) -> bool;
}
extern "C" {
    pub fn libelec_cb_get_temp(comp: *const elec_comp_t) -> f64;
}
extern "C" {
    pub fn libelec_tie_set_list(
        comp: *mut elec_comp_t,
        list_len: usize,
        bus_list: *const *mut elec_comp_t,
    );
}
extern "C" {
    pub fn libelec_tie_set(comp: *mut elec_comp_t, ...);
}
extern "C" {
    pub fn libelec_tie_set_v(comp: *mut elec_comp_t, ap: *mut __va_list_tag);
}
extern "C" {
    pub fn libelec_tie_set_all(comp: *mut elec_comp_t, tied: bool);
}
extern "C" {
    pub fn libelec_tie_get_all(comp: *mut elec_comp_t) -> bool;
}
extern "C" {
    pub fn libelec_tie_get_list(
        comp: *mut elec_comp_t,
        cap: usize,
        bus_list: *mut *mut elec_comp_t,
    ) -> usize;
}
extern "C" {
    pub fn libelec_tie_get_num_buses(comp: *const elec_comp_t) -> usize;
}
extern "C" {
    pub fn libelec_tie_get(tie: *mut elec_comp_t, exhaustive: bool_t, ...) -> bool;
}
extern "C" {
    pub fn libelec_tie_get_v(
        tie: *mut elec_comp_t,
        exhaustive: bool,
        ap: *mut __va_list_tag,
    ) -> bool;
}
extern "C" {
    pub fn libelec_batt_get_chg_rel(batt: *const elec_comp_t) -> f64;
}
extern "C" {
    pub fn libelec_batt_set_chg_rel(batt: *mut elec_comp_t, chg_rel: f64);
}
extern "C" {
    pub fn libelec_chgr_get_working(chgr: *const elec_comp_t) -> bool;
}
extern "C" {
    pub fn libelec_phys_get_batt_voltage(U_nominal: f64, chg_rel: f64, I_rel: f64) -> f64;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
